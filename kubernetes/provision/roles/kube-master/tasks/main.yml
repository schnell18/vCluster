---
# tasks file for kube-master

- name: install pre-requisite warez
  apt:
    default_release: buster
    name: "{{ packages }}"
  vars:
    packages:
    - python3-pip
    - golang-cfssl
# - name: install pyOpenSSL
#   pip:
#     name: pyOpenSSL

# download kubernetes binaries for master
- name: test if kubernetes binaries for master are downloaded
  stat:
    path: /work/.preload/kube-apiserver
  register: pmkb
- name: download kubernetes master components
  shell: "{{ lookup('template', 'download-master.sh') }}"
  args:
    executable: /bin/bash
  when: "pmkb.stat.exists == False"

# install kubernetes binaries for master
- name: test if kubernetes binaries for master are installed
  stat:
    path: /usr/local/bin/kube-apiserver
  register: pmk
- name: install kubernetes master components
  shell: "{{ lookup('template', 'install-master.sh') }}"
  args:
    executable: /bin/bash
  when: "pmk.stat.exists == False"

- name: ensure /var/kubernetes/lib exists
  file:
    path: /var/lib/kubernetes
    state: directory
# generate api server certificate
- name: test if api server certificate is genereated
  stat:
    path: /var/lib/kubernetes/kubernetes.pem
  register: cert
- name: generate api server certificate
  shell: "{{ lookup('template', 'gen-kube-apiserver-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
- name: test if etcd kube client certificate is copied
  stat:
    path: /var/lib/kubernetes/etcd-kube-client.pem
  register: cert
- name: copy etcd kube client certificate from etcd
  copy:
    src: "{{ item }}"
    dest: "{{ kube_data_dir }}/"
    remote_src: True
    owner: root
    group: root
  with_items:
    - "{{ etcd_data_dir }}/default/etcd-kube-client.pem"
    - "{{ etcd_data_dir }}/default/etcd-kube-client-key.pem"
  when: "cert.stat.exists == False"

# generate kube controller manager certificate
- name: test if kube controller manager certificate is genereated
  stat:
    path: /var/lib/kubernetes/kube-controller-manager.pem
  register: cert
- name: generate kube controller manager certificate
  shell: "{{ lookup('template', 'gen-kube-controller-manager-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate kube admin certificate
- name: test if kubernetes admin certificate is genereated
  stat:
    path: /var/lib/kubernetes/admin.pem
  register: cert
- name: generate kubernetes admin certificate
  shell: "{{ lookup('template', 'gen-kube-admin-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"

# generate service account certificate
- name: test if service account certificate is genereated
  stat:
    path: /var/lib/kubernetes/service-account.pem
  register: cert
- name: generate service account certificate
  shell: "{{ lookup('template', 'gen-kube-service-account-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"

# generate kube proxy certificate
- name: test if kube proxy certificate is genereated
  stat:
    path: /var/lib/kubernetes/kube-proxy.pem
  register: cert
- name: generate kube proxy certificate
  shell: "{{ lookup('template', 'gen-kube-proxy-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"

# generate .kubeconfig for scheduler
- name: test if kube-scheduler.kubeconfig is genereated
  stat:
    path: "{{ kube_data_dir }}/kube-scheduler.kubeconfig"
  register: conf
- name: generate kube-scheduler.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-scheduler-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for controller manager
- name: test if kube-controller-manager.kubeconfig is genereated
  stat:
    path: "{{ kube_data_dir }}/kube-controller-manager.kubeconfig"
  register: conf
- name: generate kube-controller-manager.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-controller-manager-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for admin
- name: test if admin.kubeconfig is genereated
  stat:
    path: /home/devel/.kube/config
  register: aconf
- name: generate admin.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-admin-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "aconf.stat.exists == False"

# generate .kubeconfig for proxy
- name: test if kube-proxy.kubeconfig is genereated
  stat:
    path: "{{ kube_data_dir }}/kube-proxy.kubeconfig"
  register: conf
- name: generate kube-proxy.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-proxy-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for each node
- name: generate .kubeconfig for each node
  shell: "{{ lookup('template', 'gen-node-cert-conf.sh') }}"
  args:
    executable: /bin/bash
  with_items:
    - "{{ groups['slave'] }}"

# - name: ensure /var/kubernetes/lib exists
#   file:
#     path: /var/lib/kubernetes
#     state: directory
# - name: generate ownca private key
#   openssl_privatekey:
#     path: /var/lib/kubernetes/ownca-key.pem
# - name: generate certificate request for ownca
#   openssl_csr:
#     path: /var/lib/kubernetes/ownca.csr
#     privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     key_usage: 
#       - digitalSignature
#       - keyAgreement
#       - server auth
#     extended_key_usage: 
#       - client auth
#     common_name: jjhome own ca
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: jjhome
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-apiserver
#   openssl_certificate:
#     path: /var/lib/kubernetes/ownca.crt
#     csr_path: /var/lib/kubernetes/ownca.csr
#     provider: selfsigned
# 
# # generate certificate for master components
# - name: generate certificate for kube-apiserver
#   openssl_privatekey:
#     path: /var/lib/kubernetes/kube-apiserver-key.pem
# - name: generate certificate request for kube-apiserver
#   openssl_csr:
#     path: /var/lib/kubernetes/kube-apiserver.csr
#     privatekey_path: /var/lib/kubernetes/kube-apiserver-key.pem
#     key_usage: 
#       - key encipherment
#       - server auth
#       - client auth
#     common_name: system:kube-apiserver
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: system:kube-apiserver
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-apiserver
#   openssl_certificate:
#     path: /var/lib/kubernetes/kube-apiserver.crt
#     csr_path: /var/lib/kubernetes/kube-apiserver.csr
#     ownca_path: /var/lib/kubernetes/ownca.crt
#     ownca_privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     provider: ownca
# 
# - name: generate certificate for kube-proxy
#   openssl_privatekey:
#     path: /var/lib/kubernetes/kube-proxy-key.pem
# - name: generate certificate request for kube-proxy
#   openssl_csr:
#     path: /var/lib/kubernetes/kube-proxy.csr
#     privatekey_path: /var/lib/kubernetes/kube-proxy-key.pem
#     key_usage: 
#       - key encipherment
#       - server auth
#       - client auth
#     common_name: system:kube-proxy
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: system:kube-proxy
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-proxy
#   openssl_certificate:
#     path: /var/lib/kubernetes/kube-proxy.crt
#     csr_path: /var/lib/kubernetes/kube-proxy.csr
#     ownca_path: /var/lib/kubernetes/ownca.crt
#     ownca_privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     provider: ownca
# 

# run kubernetes services

- name: ensure /var/kubernetes/lib exists
  file:
    path: /var/lib/kubernetes/config
    state: directory
- name: generate encryption config file for kube-apiserver
  template:
    src: encryption-config.yaml.j2
    dest: /var/lib/kubernetes/config/encryption-config.yaml
    mode: 0640
  notify: restart kube-apiserver

- name: enable and start kube-apiserver daemon
  template:
    src: kube-apiserver.service.j2
    dest: /etc/systemd/system/kube-apiserver.service
    mode: 0644
  notify: restart kube-apiserver

- name: enable and start kube-controller-manager daemon
  template:
    src: kube-controller-manager.service.j2
    dest: /etc/systemd/system/kube-controller-manager.service
    mode: 0644
  notify: restart kube-controller-manager

- name: generate config file for kube-scheduler
  template:
    src: kube-scheduler.yaml.j2
    dest: /var/lib/kubernetes/config/kube-scheduler.yaml
    mode: 0640
  notify: restart kube-scheduler

- name: enable and start kube-scheduler daemon
  template:
    src: kube-scheduler.service.j2
    dest: /etc/systemd/system/kube-scheduler.service
    mode: 0644
  notify: restart kube-scheduler

- meta: flush_handlers

- name: Wait for kube-apiserver fully started
  wait_for:
    delay: 10
    timeout: 270
    path: /var/log/daemon.log
    search_regex: "/apis/rbac.authorization.k8s.io/v1/clusterroles"

- name: Test if RBAC roles are created
  command: kubectl get clusterroles/system:kube-apiserver-to-kubelet
  ignore_errors: True
  register: kbcr
- name: Create RBAC roles
  shell: "{{ lookup('template', 'kubectl-rbac.sh') }}"
  args:
    executable: /bin/bash
  when: kbcr.rc != 0
- name: Test if secrets are loaded
  command: kubectl get secrets/root-ca-certs -n kube-system
  ignore_errors: True
  register: kbst
- name: Load secrets for certificates
  shell: "{{ lookup('template', 'kubectl-secrets.sh') }}"
  args:
    executable: /bin/bash
  when: kbst.rc != 0
- name: Test if calico is configured
  command: kubectl get daemonsets/calico-node -n kube-system
  ignore_errors: True
  register: kbds
- name: Load calico network settings
  shell: "{{ lookup('template', 'kubectl-calico.sh') }}"
  args:
    executable: /bin/bash
  when: kbds.rc != 0
- name: Test if kube-dns is configured
  command: kubectl get deployments/kube-dns -n kube-system
  ignore_errors: True
  register: kbns
- name: Load kube-dns settings
  shell: "{{ lookup('template', 'kubectl-dns.sh') }}"
  args:
    executable: /bin/bash
  when: kbns.rc != 0