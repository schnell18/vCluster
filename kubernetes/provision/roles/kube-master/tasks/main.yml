---
# tasks file for kube-master

- name: install pre-requisite warez
  apt:
    default_release: buster
    name: "{{ packages }}"
  vars:
    packages:
    - python3-pip
    - golang-cfssl
- name: install pyOpenSSL
  pip:
    name: pyOpenSSL

# download kubernetes binaries for master
- name: test if kubernetes binaries for master are downloaded
  stat:
    path: /work/.preload/kube-apiserver
  register: pmkb
- name: download kubernetes master components
  shell: "{{ lookup('template', 'download-master.sh') }}"
  args:
    executable: /bin/bash
  when: "pmkb.stat.exists == False"

# install kubernetes binaries for master
- name: test if kubernetes binaries for master are installed
  stat:
    path: /usr/local/bin/kube-apiserver
  register: pmk
- name: install kubernetes master components
  shell: "{{ lookup('template', 'install-master.sh') }}"
  args:
    executable: /bin/bash
  when: "pmk.stat.exists == False"

- name: ensure /var/kubernetes/lib exists
  file:
    path: /var/lib/kubernetes
    state: directory
# generate ownca certificate for signing
- name: test if own ca is genereated
  stat:
    path: /var/lib/kubernetes/ownca.pem
  register: ownca
- name: generate own ca
  shell: "{{ lookup('template', 'gen-ownca.sh') }}"
  args:
    executable: /bin/bash
  when: "ownca.stat.exists == False"
# generate api server certificate
- name: test if api server certificate is genereated
  stat:
    path: /var/lib/kubernetes/kubernetes.pem
  register: cert
- name: generate api server certificate
  shell: "{{ lookup('template', 'gen-kube-apiserver-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate kube proxy certificate
- name: test if kube proxy certificate is genereated
  stat:
    path: /var/lib/kubernetes/kube-proxy.pem
  register: cert
- name: generate kube proxy certificate
  shell: "{{ lookup('template', 'gen-kube-proxy-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate kube controller manager certificate
- name: test if kube controller manager certificate is genereated
  stat:
    path: /var/lib/kubernetes/kube-controller-manager.pem
  register: cert
- name: generate kube controller manager certificate
  shell: "{{ lookup('template', 'gen-kube-controller-manager-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate kube admin certificate
- name: test if kubernetes admin certificate is genereated
  stat:
    path: /var/lib/kubernetes/admin.pem
  register: cert
- name: generate kubernetes admin certificate
  shell: "{{ lookup('template', 'gen-kube-admin-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate service account certificate
- name: test if service account certificate is genereated
  stat:
    path: /var/lib/kubernetes/service-account.pem
  register: cert
- name: generatekube service account certificate
  shell: "{{ lookup('template', 'gen-kube-service-account-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"
# generate kube proxy certificate
- name: test if kube proxy certificate is genereated
  stat:
    path: /var/lib/kubernetes/kube-proxy.pem
  register: cert
- name: generate kube proxy certificate
  shell: "{{ lookup('template', 'gen-kube-proxy-cert.sh') }}"
  args:
    executable: /bin/bash
  when: "cert.stat.exists == False"


# generate .kubeconfig for scheduler
- name: test if kube-scheduler.kubeconfig is genereated
  stat:
    path: "{{ kube_data_dir }}/kube-scheduler.kubeconfig"
  register: conf
- name: generate kube-scheduler.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-scheduler-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for controller manager
- name: test if kube-controller-manager.kubeconfig is genereated
  stat:
    path: "{{ kube_data_dir }}/kube-controller-manager.kubeconfig"
  register: conf
- name: generate kube-controller-manager.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-controller-manager-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for admin
- name: test if admin.kubeconfig is genereated
  stat:
    path: /home/devel/.kube/config
  register: aconf
- name: generate admin.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-admin-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "aconf.stat.exists == False"

# generate .kubeconfig for proxy
- name: test if kube-proxy.kubeconfig is genereated
  stat:
    path: "{{ temp_data_dir }}/kube-proxy.kubeconfig"
  register: conf
- name: generate kube-proxy.kubeconfig
  shell: "{{ lookup('template', 'gen-kube-proxy-conf.sh') }}"
  args:
    executable: /bin/bash
  when: "conf.stat.exists == False"

# generate .kubeconfig for each node
- name: generate .kubeconfig for each node
  shell: "{{ lookup('template', 'gen-node-cert-conf.sh') }}"
  args:
    executable: /bin/bash
  with_items:
    - "{{ groups['slave'] }}"

# - name: ensure /var/kubernetes/lib exists
#   file:
#     path: /var/lib/kubernetes
#     state: directory
# - name: generate ownca private key
#   openssl_privatekey:
#     path: /var/lib/kubernetes/ownca-key.pem
# - name: generate certificate request for ownca
#   openssl_csr:
#     path: /var/lib/kubernetes/ownca.csr
#     privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     key_usage: 
#       - digitalSignature
#       - keyAgreement
#       - server auth
#     extended_key_usage: 
#       - client auth
#     common_name: jjhome own ca
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: jjhome
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-apiserver
#   openssl_certificate:
#     path: /var/lib/kubernetes/ownca.crt
#     csr_path: /var/lib/kubernetes/ownca.csr
#     provider: selfsigned
# 
# # generate certificate for master components
# - name: generate certificate for kube-apiserver
#   openssl_privatekey:
#     path: /var/lib/kubernetes/kube-apiserver-key.pem
# - name: generate certificate request for kube-apiserver
#   openssl_csr:
#     path: /var/lib/kubernetes/kube-apiserver.csr
#     privatekey_path: /var/lib/kubernetes/kube-apiserver-key.pem
#     key_usage: 
#       - key encipherment
#       - server auth
#       - client auth
#     common_name: system:kube-apiserver
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: system:kube-apiserver
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-apiserver
#   openssl_certificate:
#     path: /var/lib/kubernetes/kube-apiserver.crt
#     csr_path: /var/lib/kubernetes/kube-apiserver.csr
#     ownca_path: /var/lib/kubernetes/ownca.crt
#     ownca_privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     provider: ownca
# 
# - name: generate certificate for kube-proxy
#   openssl_privatekey:
#     path: /var/lib/kubernetes/kube-proxy-key.pem
# - name: generate certificate request for kube-proxy
#   openssl_csr:
#     path: /var/lib/kubernetes/kube-proxy.csr
#     privatekey_path: /var/lib/kubernetes/kube-proxy-key.pem
#     key_usage: 
#       - key encipherment
#       - server auth
#       - client auth
#     common_name: system:kube-proxy
#     country_name: CN
#     state_or_province_name: Shanghai
#     locality_name: Shanghai
#     organization_name: system:kube-proxy
#     organizational_unit_name: jjhome
#     state: present
# - name: generate certificate for kube-proxy
#   openssl_certificate:
#     path: /var/lib/kubernetes/kube-proxy.crt
#     csr_path: /var/lib/kubernetes/kube-proxy.csr
#     ownca_path: /var/lib/kubernetes/ownca.crt
#     ownca_privatekey_path: /var/lib/kubernetes/ownca-key.pem
#     provider: ownca
# 